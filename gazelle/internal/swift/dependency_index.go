package swift

import (
	"bytes"
	"encoding/json"
	"sort"

	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/rule"
	"github.com/cgrindel/swift_bazel/gazelle/internal/swiftpkg"
)

type bazelMap map[string][]string

type DependencyIndex struct {
	// Key: Module name
	// Value: Slice of module pointers
	moduleByName map[string][]*Module
}

func NewDependencyIndex() *DependencyIndex {
	return &DependencyIndex{
		moduleByName: make(map[string][]*Module),
	}
}

func newDependencyIndexFromBazelMap(bzlMap bazelMap) (*DependencyIndex, error) {
	di := NewDependencyIndex()
	for modName, labelStrs := range bzlMap {
		for _, labelStr := range labelStrs {
			lbl, err := label.Parse(labelStr)
			if err != nil {
				return nil, err
			}
			m := NewModule(modName, lbl)
			di.AddModule(m)
		}
	}
	return di, nil
}

func NewDependencyIndexFromJSON(data []byte) (*DependencyIndex, error) {
	var bzlMap bazelMap
	if err := json.Unmarshal(data, &bzlMap); err != nil {
		return nil, err
	}
	return newDependencyIndexFromBazelMap(bzlMap)
}

func (di *DependencyIndex) AddModule(m *Module) {
	modules := di.moduleByName[m.Name]
	modules = append(modules, m)
	di.moduleByName[m.Name] = modules
}

// Find the module given the Bazel repo name and the Swift module name.
func (di *DependencyIndex) ResolveModule(repoName, moduleName string) *Module {
	modules := di.moduleByName[moduleName]
	if len(modules) == 0 {
		return nil
	}
	// Look for module with the same repo name
	for _, module := range modules {
		if repoName == module.Label.Repo {
			return module
		}
	}
	// Else pick the first one
	return modules[0]
}

func (di *DependencyIndex) ModuleNames() []string {
	names := make([]string, len(di.moduleByName))
	idx := 0
	for modName := range di.moduleByName {
		names[idx] = modName
		idx++
	}
	return names
}

func (di *DependencyIndex) AddModules(modules ...*Module) {
	for _, m := range modules {
		di.AddModule(m)
	}
}

// This is used to index any repository rules that are not already included in the module index
// generated by update-repos. In other words, the swift_package repo rules are not indexed here
// because their contents are already included in the module index JSON file.
func (di *DependencyIndex) IndexRepoRule(r *rule.Rule, repoRoot string) error {
	var err error
	switch r.Kind() {
	case HTTPArchiveRuleKind:
		err = di.indexHTTPArchive(r, repoRoot)
	}
	return err
}

func (di *DependencyIndex) indexHTTPArchive(r *rule.Rule, repoRoot string) error {
	ha, err := NewHTTPArchiveFromRule(r, repoRoot)
	if err != nil {
		return err
	}
	if ha == nil {
		return nil
	}
	di.AddModules(ha.Modules...)
	return nil
}

func (di *DependencyIndex) IndexBazelRepo(bzlRepo *BazelRepo) error {
	return di.indexPkgInfo(bzlRepo.PkgInfo, bzlRepo.Name)
}

func (di *DependencyIndex) indexPkgInfo(pi *swiftpkg.PackageInfo, repoName string) error {
	var err error

	// Index targets
	modules := make([]*Module, len(pi.Targets))
	for idx, t := range pi.Targets {
		modules[idx], err = NewModuleFromTarget(repoName, t)
		if err != nil {
			return err
		}
	}

	// Index products
	// GH052: Index products

	di.AddModules(modules...)

	return nil
}

func (di *DependencyIndex) bazelMap() bazelMap {
	bzlMap := make(map[string][]string)
	for modName, mods := range di.moduleByName {
		labels := make([]string, len(mods))
		for idx, mod := range mods {
			labels[idx] = mod.Label.String()
		}
		// Sort the labels to ensure that they are consistent.
		sort.Strings(labels)
		bzlMap[modName] = labels
	}
	return bzlMap
}

func (di *DependencyIndex) JSON() ([]byte, error) {
	b, err := json.Marshal(di.bazelMap())
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = json.Indent(&buf, b, "", "  ")
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
