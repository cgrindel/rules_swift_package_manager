package swift

import (
	"bytes"
	"encoding/json"

	"github.com/bazelbuild/bazel-gazelle/rule"
)

type DependencyIndex struct {
	ModuleIndex  ModuleIndex  `json:"modules"`
	ProductIndex ProductIndex `json:"products"`
}

func NewDependencyIndex() *DependencyIndex {
	return &DependencyIndex{
		ModuleIndex:  make(ModuleIndex),
		ProductIndex: make(ProductIndex),
	}
}

// func newDependencyIndexFromJSONData(jsonData *indexJSONData) (*DependencyIndex, error) {
// 	// di := NewDependencyIndex()
// 	// for modName, labelStrs := range jsonData.Modules {
// 	// 	for _, labelStr := range labelStrs {
// 	// 		lbl, err := label.Parse(labelStr)
// 	// 		if err != nil {
// 	// 			return nil, err
// 	// 		}
// 	// 		m := NewModule(modName, lbl)
// 	// 		di.AddModule(m)
// 	// 	}
// 	// }
// 	// di.ProductIndex = jsonData.Products
// 	// return di, nil
// 	// TODO(chuck): IMPLEMENT ME!
// 	return nil, nil
// }

func NewDependencyIndexFromJSON(data []byte) (*DependencyIndex, error) {
	var di DependencyIndex
	if err := json.Unmarshal(data, &di); err != nil {
		return nil, err
	}
	return &di, nil
}

// This is used to index any repository rules that are not already included in the module index
// generated by update-repos. In other words, the swift_package repo rules are not indexed here
// because their contents are already included in the module index JSON file.
func (di *DependencyIndex) IndexRepoRule(r *rule.Rule, repoRoot string) error {
	var err error
	switch r.Kind() {
	case HTTPArchiveRuleKind:
		err = di.indexHTTPArchive(r, repoRoot)
	}
	return err
}

func (di *DependencyIndex) indexHTTPArchive(r *rule.Rule, repoRoot string) error {
	ha, err := NewHTTPArchiveFromRule(r, repoRoot)
	if err != nil {
		return err
	}
	if ha == nil {
		return nil
	}
	di.ModuleIndex.Add(ha.Modules...)
	return nil
}

func (di *DependencyIndex) IndexBazelRepo(bzlRepo *BazelRepo) error {
	var err error
	pi := bzlRepo.PkgInfo
	repoName := bzlRepo.Name

	// Index modules
	modules := make([]*Module, len(pi.Targets))
	for idx, t := range pi.Targets {
		modules[idx], err = NewModuleFromTarget(repoName, t)
		if err != nil {
			return err
		}
	}
	di.ModuleIndex.Add(modules...)

	// Index products
	for _, p := range pi.Products {
		prd, err := NewProductFromPkgInfoProduct(bzlRepo, p)
		if err != nil {
			return err
		}
		di.ProductIndex.Add(prd)
	}

	return nil
}

// func (di *DependencyIndex) jsonOutput() *indexJSONData {
// 	jd := &indexJSONData{
// 		Modules: make(modulesJSONData),
// 		Products: make(productsJSONData),
// 	}
// 	for modName, mods := range di.ModuleIndex {
// 		labels := make([]string, len(mods))
// 		for idx, mod := range mods {
// 			labels[idx] = mod.Label.String()
// 		}
// 		// Sort the labels to ensure that they are consistent.
// 		sort.Strings(labels)
// 		jd.Modules[modName] = labels
// 	}
// 	return jd
// }

// func (di *DependencyIndex) MarshalJSON() ([]byte, error) {
// 	b, err := json.Marshal(di.jsonOutput())
// 	if err != nil {
// 		return nil, err
// 	}
// 	var buf bytes.Buffer
// 	err = json.Indent(&buf, b, "", "  ")
// 	if err != nil {
// 		return nil, err
// 	}
// 	return buf.Bytes(), nil
// }

func (di *DependencyIndex) JSON() ([]byte, error) {
	b, err := json.Marshal(di)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = json.Indent(&buf, b, "", "  ")
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
