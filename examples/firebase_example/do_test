#!/usr/bin/env bash

set -o errexit -o nounset -o pipefail

print_and_run() {
  local cmd="${1}"
  shift 1
  printf >&2 "======================\n%s: %s %s\n======================\n" \
    "$(basename "${BASH_SOURCE[0]}")" "$(basename "${cmd}")" "$*"
  "${cmd}" "$@"
}

# Use the Bazel binary specified by the integration test. Otherise, fall back 
# to bazel.
bazel="${BIT_BAZEL_BINARY:-bazel}"

# DEBUG BEGIN
echo >&2 "*** CHUCK $(basename "${BASH_SOURCE[0]}") MADE IT" 
exit 1
# DEBUG END

# Generate Swift external deps and update build files
print_and_run "${bazel}" run //:tidy

# Ensure that it builds and tests pass
print_and_run "${bazel}" test //...

# The analytics/AnalyticsExample generates an Xcode project using
# rules_xcodeproj. The following ensures that the project generates properly
# and that the project builds as rules_xcodeproj executes the build.
# Related:
# https://github.com/MobileNativeFoundation/rules_xcodeproj/issues/2703


# # Generate a bazel script for rules_xcodeproj to use. This script ensures that
# # the xcodeproj runner uses the Bazel that is under test. We configure the
# # xcodeproj macro to find this generated bazel script.
# bazel_for_xcodeproj="${script_dir}/bazel_for_xcodeproj"
# backup="${bazel_for_xcodeproj}.bak"
# cleanup() {
#   if [[ -e "${backup}" ]]; then
#     mv -f "${backup}" "${bazel_for_xcodeproj}"
#   fi
# }
# trap cleanup EXIT
# mv -f "${bazel_for_xcodeproj}" "${backup}"
# cat >"${bazel_for_xcodeproj}" <<-EOF
# #!/usr/bin/env bash
# 
# set -o errexit -o nounset -o pipefail
# 
# # Use the Bazel binary that we specify.
# bazel="${bazel}"
# 
# # Execute the Bazel command
# "\${bazel}" "\${@}"
# EOF
# chmod +x "${bazel_for_xcodeproj}"

# Generate the Xcode project
print_and_run "${bazel}" run //analytics/AnalyticsExample:xcodeproj

# Build the workspace
print_and_run "${bazel}" run //analytics/AnalyticsExample:xcodeproj -- \
  --generator_output_groups=all_targets 'build --remote_download_minimal'
