"""Implementation for `swift_deps` bzlmod extension."""

load("//swiftpkg/internal:deps_indexes.bzl", "deps_indexes")
load("//swiftpkg/internal:local_swift_package.bzl", "local_swift_package")
load("//swiftpkg/internal:swift_package.bzl", "swift_package")

# MARK: - swift_deps bzlmod Extension

def _declare_pkg_from_package(package, deps_index_label, config_pkg):
    if package.remote_pkg != None:
        remote_pkg = package.remote_pkg
        init_submodules = None
        recursive_init_submodules = None
        if config_pkg:
            init_submodules = config_pkg.init_submodules
            recursive_init_submodules = config_pkg.recursive_init_submodules

        patch_args = None
        patch_cmds = None
        patch_cmds_win = None
        patch_tool = None
        patches = None
        patch = remote_pkg.patch
        if patch != None:
            patch_args = patch.args
            patch_cmds = patch.cmds
            patch_cmds_win = patch.win_cmds
            patch_tool = patch.tool
            patches = patch.files

        swift_package(
            name = package.name,
            bazel_package_name = package.name,
            commit = remote_pkg.commit,
            remote = remote_pkg.remote,
            dependencies_index = deps_index_label,
            init_submodules = init_submodules,
            recursive_init_submodules = recursive_init_submodules,
            patch_args = patch_args,
            patch_cmds = patch_cmds,
            patch_cmds_win = patch_cmds_win,
            patch_tool = patch_tool,
            patches = patches,
        )
    elif package.local_pkg != None:
        local_swift_package(
            name = package.name,
            bazel_package_name = package.name,
            path = package.local_pkg.path,
            dependencies_index = deps_index_label,
        )
    else:
        fail("Found package '{}' without a remote or local.".format(
            package.identity,
        ))

def _declare_pkgs_from_file(module_ctx, from_file, config_pkgs):
    index_json = module_ctx.read(from_file.deps_index)
    deps_index = deps_indexes.new_from_json(index_json)
    for package in deps_index.packages_by_id.values():
        config_pkg = config_pkgs.get(package.name)
        _declare_pkg_from_package(package, from_file.deps_index, config_pkg)

def _swift_deps_impl(module_ctx):
    config_pkgs = {}
    for mod in module_ctx.modules:
        for config_pkg in mod.tags.configure_package:
            config_pkgs[config_pkg.name] = config_pkg
    for mod in module_ctx.modules:
        for from_file in mod.tags.from_file:
            _declare_pkgs_from_file(module_ctx, from_file, config_pkgs)

_from_file_tag = tag_class(
    attrs = {
        "deps_index": attr.label(
            mandatory = True,
            doc = "A `swift_deps_index.json`.",
        ),
    },
    doc = "Load Swift packages from a file generated by the Gazelle extension.",
)

_configure_package_tag = tag_class(
    attrs = {
        "init_submodules": attr.bool(
            default = False,
            doc = "Whether to clone submodules in the repository.",
        ),
        "name": attr.string(
            doc = "The Bazel repository name for the Swift package.",
            mandatory = True,
        ),
        "recursive_init_submodules": attr.bool(
            default = True,
            doc = "Whether to clone submodules recursively in the repository.",
        ),
    },
    doc = "Used to add or override settings for a particular Swift package.",
)

swift_deps = module_extension(
    implementation = _swift_deps_impl,
    tag_classes = {
        "configure_package": _configure_package_tag,
        "from_file": _from_file_tag,
    },
)
