gazelle: *** CHUCK: Resolve =========
gazelle: *** CHUCK: Resolve ix: &resolve.RuleIndex{rules:[]*resolve.ruleRecord(nil), labelMap:map[label.Label]*resolve.ruleRecord{}, importMap:map[resolve.ImportSpec][]*resolve.ruleRecord{}, mrslv:(func(*rule.Rule, string) resolve.Resolver)(0x12c5000), crossResolvers:[]resolve.CrossResolver(nil)}
gazelle: *** CHUCK: Resolve rc: &repo.RemoteCache{RepoRootForImportPath:(func(string, bool) (*vcs.RepoRoot, error))(0x12a36a0), HeadCmd:(func(string, string) (string, error))(0x12a73e0), ModInfo:(func(string) (string, error))(0x12a7320), ModVersionInfo:(func(string, string) (string, string, error))(0x12a72a0), root:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, remote:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, head:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, mod:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, modVersion:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, tmpOnce:sync.Once{done:0x0, m:sync.Mutex{state:0, sema:0x0}}, tmpDir:"", tmpErr:error(nil)}
gazelle: *** CHUCK: Resolve r: &rule.Rule{stmt:rule.stmt{index:0, deleted:false, inserted:true, updated:true, comments:[]string(nil), commentsUpdated:false, expr:(*build.CallExpr)(0xc0001c8c30)}, kind:"swift_binary", args:[]build.Expr(nil), attrs:map[string]*build.AssignExpr{"name":(*build.AssignExpr)(0xc0001b8280), "srcs":(*build.AssignExpr)(0xc0001b83c0)}, private:map[string]interface {}{"_gazelle_imports":[]string{"ArgumentParser", "Foundation"}}}
gazelle: *** CHUCK: Resolve imports: []string{"ArgumentParser", "Foundation"}
gazelle: *** CHUCK: Resolve from: label.Label{Repo:"", Pkg:"Sources/CountLines", Name:"CountLines", Relative:false}
gazelle: *** CHUCK: Resolve =========
gazelle: *** CHUCK: Resolve ix: &resolve.RuleIndex{rules:[]*resolve.ruleRecord(nil), labelMap:map[label.Label]*resolve.ruleRecord{}, importMap:map[resolve.ImportSpec][]*resolve.ruleRecord{}, mrslv:(func(*rule.Rule, string) resolve.Resolver)(0x12c5000), crossResolvers:[]resolve.CrossResolver(nil)}
gazelle: *** CHUCK: Resolve rc: &repo.RemoteCache{RepoRootForImportPath:(func(string, bool) (*vcs.RepoRoot, error))(0x12a36a0), HeadCmd:(func(string, string) (string, error))(0x12a73e0), ModInfo:(func(string) (string, error))(0x12a7320), ModVersionInfo:(func(string, string) (string, string, error))(0x12a72a0), root:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, remote:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, head:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, mod:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, modVersion:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, tmpOnce:sync.Once{done:0x0, m:sync.Mutex{state:0, sema:0x0}}, tmpDir:"", tmpErr:error(nil)}
gazelle: *** CHUCK: Resolve r: &rule.Rule{stmt:rule.stmt{index:0, deleted:false, inserted:true, updated:true, comments:[]string(nil), commentsUpdated:false, expr:(*build.CallExpr)(0xc0001c9950)}, kind:"swift_binary", args:[]build.Expr(nil), attrs:map[string]*build.AssignExpr{"name":(*build.AssignExpr)(0xc0001b85a0), "srcs":(*build.AssignExpr)(0xc0001b8780)}, private:map[string]interface {}{"_gazelle_imports":[]string{"ArgumentParser"}}}
gazelle: *** CHUCK: Resolve imports: []string{"ArgumentParser"}
gazelle: *** CHUCK: Resolve from: label.Label{Repo:"", Pkg:"Sources/Repeat", Name:"Repeat", Relative:false}
gazelle: *** CHUCK: Resolve =========
gazelle: *** CHUCK: Resolve ix: &resolve.RuleIndex{rules:[]*resolve.ruleRecord(nil), labelMap:map[label.Label]*resolve.ruleRecord{}, importMap:map[resolve.ImportSpec][]*resolve.ruleRecord{}, mrslv:(func(*rule.Rule, string) resolve.Resolver)(0x12c5000), crossResolvers:[]resolve.CrossResolver(nil)}
gazelle: *** CHUCK: Resolve rc: &repo.RemoteCache{RepoRootForImportPath:(func(string, bool) (*vcs.RepoRoot, error))(0x12a36a0), HeadCmd:(func(string, string) (string, error))(0x12a73e0), ModInfo:(func(string) (string, error))(0x12a7320), ModVersionInfo:(func(string, string) (string, string, error))(0x12a72a0), root:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, remote:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, head:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, mod:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, modVersion:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, tmpOnce:sync.Once{done:0x0, m:sync.Mutex{state:0, sema:0x0}}, tmpDir:"", tmpErr:error(nil)}
gazelle: *** CHUCK: Resolve r: &rule.Rule{stmt:rule.stmt{index:0, deleted:false, inserted:true, updated:true, comments:[]string(nil), commentsUpdated:false, expr:(*build.CallExpr)(0xc0001ce690)}, kind:"swift_library", args:[]build.Expr(nil), attrs:map[string]*build.AssignExpr{"name":(*build.AssignExpr)(0xc0001b8960), "srcs":(*build.AssignExpr)(0xc0001b8aa0)}, private:map[string]interface {}{"_gazelle_imports":[]string{"ArgumentParser"}}}
gazelle: *** CHUCK: Resolve imports: []string{"ArgumentParser"}
gazelle: *** CHUCK: Resolve from: label.Label{Repo:"", Pkg:"Sources/Roll", Name:"Roll", Relative:false}
gazelle: *** CHUCK: Resolve =========
gazelle: *** CHUCK: Resolve ix: &resolve.RuleIndex{rules:[]*resolve.ruleRecord(nil), labelMap:map[label.Label]*resolve.ruleRecord{}, importMap:map[resolve.ImportSpec][]*resolve.ruleRecord{}, mrslv:(func(*rule.Rule, string) resolve.Resolver)(0x12c5000), crossResolvers:[]resolve.CrossResolver(nil)}
gazelle: *** CHUCK: Resolve rc: &repo.RemoteCache{RepoRootForImportPath:(func(string, bool) (*vcs.RepoRoot, error))(0x12a36a0), HeadCmd:(func(string, string) (string, error))(0x12a73e0), ModInfo:(func(string) (string, error))(0x12a7320), ModVersionInfo:(func(string, string) (string, string, error))(0x12a72a0), root:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, remote:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, head:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, mod:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, modVersion:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, tmpOnce:sync.Once{done:0x0, m:sync.Mutex{state:0, sema:0x0}}, tmpDir:"", tmpErr:error(nil)}
gazelle: *** CHUCK: Resolve r: &rule.Rule{stmt:rule.stmt{index:0, deleted:false, inserted:true, updated:true, comments:[]string(nil), commentsUpdated:false, expr:(*build.CallExpr)(0xc0001ce780)}, kind:"swift_library", args:[]build.Expr(nil), attrs:map[string]*build.AssignExpr{"name":(*build.AssignExpr)(0xc0001b8c80), "srcs":(*build.AssignExpr)(0xc0001b8dc0)}, private:map[string]interface {}{"_gazelle_imports":[]string{}}}
gazelle: *** CHUCK: Resolve imports: []string{}
gazelle: *** CHUCK: Resolve from: label.Label{Repo:"", Pkg:"Sources/StringUtils", Name:"StringUtils", Relative:false}
gazelle: *** CHUCK: Resolve =========
gazelle: *** CHUCK: Resolve ix: &resolve.RuleIndex{rules:[]*resolve.ruleRecord(nil), labelMap:map[label.Label]*resolve.ruleRecord{}, importMap:map[resolve.ImportSpec][]*resolve.ruleRecord{}, mrslv:(func(*rule.Rule, string) resolve.Resolver)(0x12c5000), crossResolvers:[]resolve.CrossResolver(nil)}
gazelle: *** CHUCK: Resolve rc: &repo.RemoteCache{RepoRootForImportPath:(func(string, bool) (*vcs.RepoRoot, error))(0x12a36a0), HeadCmd:(func(string, string) (string, error))(0x12a73e0), ModInfo:(func(string) (string, error))(0x12a7320), ModVersionInfo:(func(string, string) (string, string, error))(0x12a72a0), root:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, remote:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, head:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, mod:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, modVersion:repo.remoteCacheMap{mu:sync.Mutex{state:0, sema:0x0}, cache:map[string]*repo.remoteCacheEntry{}}, tmpOnce:sync.Once{done:0x0, m:sync.Mutex{state:0, sema:0x0}}, tmpDir:"", tmpErr:error(nil)}
gazelle: *** CHUCK: Resolve r: &rule.Rule{stmt:rule.stmt{index:0, deleted:false, inserted:true, updated:true, comments:[]string(nil), commentsUpdated:false, expr:(*build.CallExpr)(0xc0001cea50)}, kind:"swift_test", args:[]build.Expr(nil), attrs:map[string]*build.AssignExpr{"name":(*build.AssignExpr)(0xc0001b8fa0), "srcs":(*build.AssignExpr)(0xc0001b90e0)}, private:map[string]interface {}{"_gazelle_imports":[]string{"Truth", "XCTest"}}}
gazelle: *** CHUCK: Resolve imports: []string{"Truth", "XCTest"}
gazelle: *** CHUCK: Resolve from: label.Label{Repo:"", Pkg:"Tests/StringUtilsTests", Name:"StringUtilsTests", Relative:false}
